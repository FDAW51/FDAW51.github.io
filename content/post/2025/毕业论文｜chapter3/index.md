---

title: "毕业论文｜chapter3"
slug: "毕业论文｜chapter3"
description: 
date: "2025-05-09T14:06:10+08:00"
lastmod: "2025-05-09T14:06:10+08:00"
image: 
math: true
license: 
hidden: false
draft: false 
categories: ["毕业论文"]
tags: ["Shor算法","量子纠缠的应用","大数分解","密码破解"]

---

# 量子纠缠的应用

可能很多人会想，量子纠缠这么神秘，众多科学家历经坎坷终于证明了量子纠缠存在的合理性。那么它有什么用呢？或者说，它能够解决哪些问题呢？

对于量子纠缠，首先想到的是Alice和Bob双方共享的Bell态，只要有一方对于自己的系统进行测量，无论多远，都会影响另一方的测量结果，即纠缠的关联性。那么由此，我们可以联想到它与并行计算有同理之处，只不过，量子纠缠里的并行是双方互相影响的并行，而并行计算里是计算机对于一个大任务进行分解成许多小的，可以独立执行，或者合作完成的子任务，然后将这些子任务分配给多个处理器，让其同时进行计算。

那么这一并行或者关联的特性，能够让量子纠缠碰撞出怎么样的火花呢？首先想到的就是针对大数分解的Shor算法，它可以有效的解决应用数学里最有趣的问题之一—将大数分解成多个素数，它可以用来破解常用的RSA加密方案。

## Shor算法

### 一些前置知识

#### 数论知识

##### 素数

##### 共素

##### 最大公约数

##### 模N群

##### 模N的乘法群

##### 抽屉原理



#### 时间复杂度

#### 量子相位估计

#### 量子傅立叶变换

#### 连分数算法：

### 密码破解

对于平时用的加密方案RSA，其加密原理是：

1. 随机的选择两个大素数  $p和q$，其中 $p，q$分别代表公钥和私钥，你可以理解为，公钥是公开的，而私钥是你自己的
2. 计算模数 $n = p\times q$,这个模数 $n$是公钥和私钥的公共部分
3. 计算欧拉函数 $\phi(n) = (p-1)(q-1)$
4. 计算公钥指数e：在范围 $[1,\phi(n)]$内选择公钥指数e，并且公钥指数e和欧拉函数 $\phi(n)$ 互质(Coprime)
5. 计算私钥指数d：让 $e \times d \equiv 1 \pmod{\phi(n)}$，即d是e关于模 $\phi(n)$的乘法逆元。
6. 最终生成了公钥$(e，n)$，私钥$(d，n)$

如果在什么都不知道的前提下，想要直接以暴力的手段破解某一个加密文件，那么就需要分解大整数n为两个大素数p和q，而分解大数这一问题在经典下最快的算法（数域筛选法）的时间复杂度（近似）是：
$$
\exp(((\frac{64}{9})^{1/3})+o(1))(\log n)^{1/3}(\log{\log n})^{2/3})
$$
虽然不是指数时间，但也比多项式时间慢很多，当解决n比较大（大约1024位）的密钥时，这个算法就不可用了。

### Shor算法的逻辑：

前面说了，经典计算里面可以通过并行计算来加速任务的完成时间，那么分解大数的问题可不可以用并行计算来处理，答案是并行计算的加速效果是线性的，而shor算法具有指数级的加速效果，并且shor算法的时间复杂度是： $O((\log{n})^3)$，所以经典中的并行计算对于任务的加速效果并不如shor算法。

那么Shor算法的逻辑是什么呢？

首先任务是：给出一个大数M，我们需要找到M的整数因子（两个大素数），这就排除了M是偶数的可能性（如果是偶数的话，2自然就是M的一个因子，并且2是比较小的素数，这就使得这个密钥不再安全），并且当M分解成一个素数和另一个非素数，我们可以逐步迭代使得M最终分解成多个素数的乘积（**这里可以注释一下给一个例子**）。

要解决这个问题有两部分：

1. 简化（Reduction）：将分解问题转换为周期查找问题（Order- Finding，后面简记为OF）
2. 解决OF问题：用量子相位估计算法来解决OF问题，其中又包含了估计相位，以及提取周期两步

### 简化

1. 首先我们在区间 $[2,M)$ 随机选择一个整数$a$，然后我们去计算 $\gcd{(a,M)}$ ($a和M的最大公约数$)，那么就会有两种情况：

   1. $\gcd{(a,M)} \neq 1$，即它们的最大公约数是G，那么M就可以分解成G和 $\frac{M}{G}$（ $\gcd{(a,M) = G}$ 表明G是M的因子，即M可以被G整除）

   2. $\gcd{(a,M)} = 1$，那么此时 $a和M共素$，则 a在模M整数乘法群（群里的元素都是和M共素且属于模M群）里，记为 $a \in \Z_M^{*}$。

2. 如果属于步骤1的第二种情况，那么通过乘法群的逆元的存在性，则a在模M整数乘法群中存在逆元 $a^{-1}$使得：
      $$
      a \times a^{-1}  = 1 \pmod{M}
      $$
      后面的 $1 \pmod{M}$表示在模M群里面的单位元1。

3. 然后由我们选择的a来生成包含不同幂次a的序列：
      $$
      X：\{a^1,a^2,\dots\}
      $$
      

      这个序列的长度是无限的,因为我们可以对a不断做取幂处理，并且我们知道：
      $$
      a \in \Z_{M}^{*},\forall k \in \N ,\exist Z_{k} \in \Z_{M}^{*}，Z_k = a^k \pmod{M}
      $$
      但是由于$Z_M^*$里面包含的元素是有限的（仅包含0，1，2，$\dots$，M-1）。

      由于抽屉原理，从序列$X$中抽出第一个元素 $a^i$，它在$\Z_M^*$所对应的元素记为 $Z_i$，那么总有一次抽出的 $a^j$，与先前抽出的元素对应着同一个 $\Z_M^*中的Z_i$，通俗的解释就是：如果将模M群中的元素记为不同的抽屉，而序列X里面包含着无数个小球，它们分布在不同抽屉中，那么一定存在两个小球属于一个抽屉

4. 对于某个 $a^{k1}$，在$\Z^*_N$中存在逆元

### 解决OF问题
$$
a \in \Z_{M}^*,\forall k \in \N ,\exist Z_{k} \in \Z_{M}^*，Z_k = a^k \pmod{M}
$$

### 效率（Performance）

$$
a \in \Z_{M}^{*},\forall k \in \N , Z_{k}  \Z_{M}^{*}，
$$



### Conclusion(总结)





## 附录:



### 参考文献

### 版权信息

本文原载于 [quantum51.top](https://quantum51.top)，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。
