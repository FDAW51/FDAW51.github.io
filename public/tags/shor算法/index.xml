<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Shor算法 on Eugene</title>
        <link>http://localhost:1313/tags/shor%E7%AE%97%E6%B3%95/</link>
        <description>Recent content in Shor算法 on Eugene</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 09 May 2025 14:06:10 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/shor%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>毕业论文｜chapter3</title>
        <link>http://localhost:1313/2025/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87chapter3/</link>
        <pubDate>Fri, 09 May 2025 14:06:10 +0800</pubDate>
        
        <guid>http://localhost:1313/2025/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87chapter3/</guid>
        <description>&lt;h1 id=&#34;量子纠缠的应用&#34;&gt;量子纠缠的应用
&lt;/h1&gt;
&lt;p&gt;可能很多人会想，量子纠缠这么神秘，众多科学家历经坎坷终于证明了量子纠缠存在的合理性。那么它有什么用呢？或者说，它能够解决哪些问题呢？&lt;/p&gt;
&lt;p&gt;对于量子纠缠，首先想到的是Alice和Bob双方共享的Bell态，只要有一方对于自己的系统进行测量，无论多远，都会影响另一方的测量结果，即纠缠的关联性。那么由此，我们可以联想到它与并行计算有同理之处，只不过，量子纠缠里的并行是双方互相影响的并行，而并行计算里是计算机对于一个大任务进行分解成许多小的，可以独立执行，或者合作完成的子任务，然后将这些子任务分配给多个处理器，让其同时进行计算。&lt;/p&gt;
&lt;p&gt;那么这一并行或者关联的特性，能够让量子纠缠碰撞出怎么样的火花呢？首先想到的就是针对大数分解的Shor算法，它可以有效的解决应用数学里最有趣的问题之一—将大数分解成多个素数，它可以用来破解常用的RSA加密方案。&lt;/p&gt;
&lt;h2 id=&#34;shor算法&#34;&gt;Shor算法
&lt;/h2&gt;
&lt;h3 id=&#34;一些前置知识&#34;&gt;一些前置知识
&lt;/h3&gt;
&lt;h4 id=&#34;数论知识&#34;&gt;数论知识
&lt;/h4&gt;
&lt;h5 id=&#34;素数&#34;&gt;素数
&lt;/h5&gt;
&lt;h5 id=&#34;共素&#34;&gt;共素
&lt;/h5&gt;
&lt;h5 id=&#34;最大公约数&#34;&gt;最大公约数
&lt;/h5&gt;
&lt;h5 id=&#34;模n群&#34;&gt;模N群
&lt;/h5&gt;
&lt;h5 id=&#34;模n的乘法群&#34;&gt;模N的乘法群
&lt;/h5&gt;
&lt;h5 id=&#34;抽屉原理&#34;&gt;抽屉原理
&lt;/h5&gt;
&lt;h4 id=&#34;时间复杂度&#34;&gt;时间复杂度
&lt;/h4&gt;
&lt;h4 id=&#34;量子相位估计&#34;&gt;量子相位估计
&lt;/h4&gt;
&lt;h4 id=&#34;量子傅立叶变换&#34;&gt;量子傅立叶变换
&lt;/h4&gt;
&lt;h4 id=&#34;连分数算法&#34;&gt;连分数算法：
&lt;/h4&gt;
&lt;h3 id=&#34;密码破解&#34;&gt;密码破解
&lt;/h3&gt;
&lt;p&gt;对于平时用的加密方案RSA，其加密原理是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随机的选择两个大素数  $p和q$，其中 $p，q$分别代表公钥和私钥，你可以理解为，公钥是公开的，而私钥是你自己的&lt;/li&gt;
&lt;li&gt;计算模数 $n = p\times q$,这个模数 $n$是公钥和私钥的公共部分&lt;/li&gt;
&lt;li&gt;计算欧拉函数 $\phi(n) = (p-1)(q-1)$&lt;/li&gt;
&lt;li&gt;计算公钥指数e：在范围 $[1,\phi(n)]$内选择公钥指数e，并且公钥指数e和欧拉函数 $\phi(n)$ 互质(Coprime)&lt;/li&gt;
&lt;li&gt;计算私钥指数d：让 $e \times d \equiv 1 \pmod{\phi(n)}$，即d是e关于模 $\phi(n)$的乘法逆元。&lt;/li&gt;
&lt;li&gt;最终生成了公钥$(e，n)$，私钥$(d，n)$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果在什么都不知道的前提下，想要直接以暴力的手段破解某一个加密文件，那么就需要分解大整数n为两个大素数p和q，而分解大数这一问题在经典下最快的算法（数域筛选法）的时间复杂度（近似）是：
$$
\exp(((\frac{64}{9})^{1/3})+o(1))(\log n)^{1/3}(\log{\log n})^{2/3})
$$
虽然不是指数时间，但也比多项式时间慢很多，当解决n比较大（大约1024位）的密钥时，这个算法就不可用了。&lt;/p&gt;
&lt;h3 id=&#34;shor算法的逻辑&#34;&gt;Shor算法的逻辑：
&lt;/h3&gt;
&lt;p&gt;前面说了，经典计算里面可以通过并行计算来加速任务的完成时间，那么分解大数的问题可不可以用并行计算来处理，答案是并行计算的加速效果是线性的，而shor算法具有指数级的加速效果，并且shor算法的时间复杂度是： $O((\log{n})^3)$，所以经典中的并行计算对于任务的加速效果并不如shor算法。&lt;/p&gt;
&lt;p&gt;那么Shor算法的逻辑是什么呢？&lt;/p&gt;
&lt;p&gt;首先任务是：给出一个大数M，我们需要找到M的整数因子（两个大素数），这就排除了M是偶数的可能性（如果是偶数的话，2自然就是M的一个因子，并且2是比较小的素数，这就使得这个密钥不再安全），并且当M分解成一个素数和另一个非素数，我们可以逐步迭代使得M最终分解成多个素数的乘积（&lt;strong&gt;这里可以注释一下给一个例子&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;要解决这个问题有两部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简化（Reduction）：将分解问题转换为周期查找问题（Order- Finding，后面简记为OF）&lt;/li&gt;
&lt;li&gt;解决OF问题：用量子相位估计算法来解决OF问题，其中又包含了估计相位，以及提取周期两步&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;简化&#34;&gt;简化
&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先我们在区间 $[2,M)$ 随机选择一个整数$a$，然后我们去计算 $\gcd{(a,M)}$ ($a和M的最大公约数$)，那么就会有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$\gcd{(a,M)} \neq 1$，即它们的最大公约数是G，那么M就可以分解成G和 $\frac{M}{G}$（ $\gcd{(a,M) = G}$ 表明G是M的因子，即M可以被G整除）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\gcd{(a,M)} = 1$，那么此时 $a和M共素$，则 a在模M整数乘法群（群里的元素都是和M共素且属于模M群）里，记为 $a \in \Z_M^{*}$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果属于步骤1的第二种情况，那么通过乘法群的逆元的存在性，则a在模M整数乘法群中存在逆元 $a^{-1}$使得：
$$
a \times a^{-1}  = 1 \pmod{M}
$$
后面的 $1 \pmod{M}$表示在模M群里面的单位元1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后由我们选择的a来生成包含不同幂次a的序列：
$$
X：{a^1,a^2,\dots}
$$&lt;/p&gt;
&lt;p&gt;这个序列的长度是无限的,因为我们可以对a不断做取幂处理，并且我们知道：
$$
a \in \Z_{M}^{&lt;em&gt;},\forall k \in \N ,\exist Z_{k} \in \Z_{M}^{&lt;/em&gt;}，Z_k = a^k \pmod{M}
$$
但是由于$Z_M^*$里面包含的元素是有限的（仅包含0，1，2，$\dots$，M-1）。&lt;/p&gt;
&lt;p&gt;由于抽屉原理，从序列$X$中抽出第一个元素 $a^i$，它在$\Z_M^*$所对应的元素记为 $Z_i$，那么总有一次抽出的 $a^j$，与先前抽出的元素对应着同一个 $\Z_M^*中的Z_i$，通俗的解释就是：如果将模M群中的元素记为不同的抽屉，而序列X里面包含着无数个小球，它们分布在不同抽屉中，那么一定存在两个小球属于一个抽屉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于某个 $a^{k1}$，在$\Z^*_N$中存在逆元&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;解决of问题&#34;&gt;解决OF问题
&lt;/h3&gt;
&lt;p&gt;$$
a \in \Z_{M}^&lt;em&gt;,\forall k \in \N ,\exist Z_{k} \in \Z_{M}^&lt;/em&gt;，Z_k = a^k \pmod{M}
$$&lt;/p&gt;
&lt;h3 id=&#34;效率performance&#34;&gt;效率（Performance）
&lt;/h3&gt;
&lt;p&gt;$$
a \in \Z_{M}^{&lt;em&gt;},\forall k \in \N , Z_{k}  \Z_{M}^{&lt;/em&gt;}，
$$&lt;/p&gt;
&lt;h3 id=&#34;conclusion总结&#34;&gt;Conclusion(总结)
&lt;/h3&gt;
&lt;h2 id=&#34;附录&#34;&gt;附录:
&lt;/h2&gt;
&lt;h3 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h3&gt;
&lt;h3 id=&#34;版权信息&#34;&gt;版权信息
&lt;/h3&gt;
&lt;p&gt;本文原载于 &lt;a class=&#34;link&#34; href=&#34;https://quantum51.top&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;quantum51.top&lt;/a&gt;，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
